package Extensions

import Core.interfaces.DBEntity
import java.sql.ResultSet
import kotlin.reflect.KClass
import kotlin.reflect.KMutableProperty
import kotlin.reflect.KParameter
import kotlin.reflect.full.createInstance
import kotlin.reflect.full.findParameterByName
import kotlin.reflect.full.memberProperties
import kotlin.reflect.full.primaryConstructor

/**
 * Created by Sanf0rd on 16/07/17.
 */
fun <T : DBEntity> ResultSet.asListOf(entity: KClass<T>): List<DBEntity> {
    val resultList: MutableList<DBEntity> = mutableListOf()


    while (this.next()) {
        val parameterMap: MutableMap<KParameter, Any> = mutableMapOf()
        var entityConstructor = entity.primaryConstructor

        val fields = entity.java.declaredFields + entity.java.superclass.declaredFields

        for (field in fields) {
            val kProperty = entity.memberProperties.find { it.name == field.name }

            if (field.isIgnore().not() && field.isAutoGeneratedMetaData().not()) {

                @Suppress("IMPLICIT_CAST_TO_ANY")
                var value = when (field.genericType) {
                    String::class.java -> this.getString(field.name)
                    Int::class.java -> this.getInt(field.name)
                    Double::class.java -> this.getDouble(field.name)
                    Float::class.java -> this.getFloat(field.name)
                    Long::class.java -> this.getLong(field.name)
                    Char::class.java -> this.getString(field.name)
                    Boolean::class.java -> if (this.getInt(field.name) == 0) true else false
                    else -> print("Unsuported type")
                }

                val parameter = entityConstructor?.findParameterByName(field.name)
                parameterMap.put(key = parameter!!, value = value)
            }

        }
        val newEntity = entityConstructor?.callBy(parameterMap)
        newEntity?.let { resultList.add(it) }
    }

    return resultList
}